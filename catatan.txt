Catatan Desain Protokol ORILINK (Melanjutkan dari SYN/SYN_ACK)

Fokus Utama Saat Ini: Setelah SYN/SYN_ACK berhasil, fokus berikutnya adalah inisiasi dan pengelolaan stream data.

1. Desain Paket ORILINK_STARTDT:

Tujuan: Memulai satu stream data baru. Satu STARTDT = Satu stream_id.

Field Penting:

stream_id (uint16_t): ID unik untuk stream ini dalam konteks connection_id.

total_transfer_size (uint64_t): Total byte yang akan ditransfer.

Penting: Untuk stream UNRELIABLE atau kontinu (misal: live streaming), ini bisa 0 atau nilai khusus untuk menandakan "tak terbatas".

stream_mode (orilink_stream_mode_t):

STREAM_MODE_RELIABLE (0x00): Untuk data yang tidak boleh hilang (transfer file).

STREAM_MODE_UNRELIABLE (0x01): Untuk data yang mentolerir kehilangan (video/audio streaming).

Tidak Ada filename: Ini sudah disepakati untuk membuat protokol lebih umum.

Pertimbangkan content_type (opsional): Jika perlu mengidentifikasi jenis data (misal: "video/h264", "application/json").

2. Manajemen Stream dan Buffer (Server):

Buffer Per stream_id: Server harus mengelola buffer penerima secara terpisah untuk setiap stream_id yang aktif.

Flow Control Per stream_id:

Setiap stream_id akan memiliki available_stream_window sendiri (jumlah byte kosong di buffer stream tersebut).

Pengirim (klien) harus mematuhi available_stream_window ini saat mengirim ORILINK_DATA untuk stream yang bersangkutan.

Penting: Tetap pertahankan available_global_receive_window untuk membatasi total buffer yang digunakan oleh semua stream dalam satu koneksi.

3. Konfirmasi Sinyal Kontrol (Wajib Dijawab dengan Timer RTT + Kalman Filter):

Sinyal Kontrol yang Wajib Dijawab:

ORILINK_SYN -> ORILINK_SYN_ACK

ORILINK_HEARTBEAT -> ORILINK_HEARTBEAT_ACK

ORILINK_STARTDT -> ORILINK_STARTDT_ACK

ORILINK_FINISHDT -> ORILINK_FINISHDT_ACK

ORILINK_FIN -> ORILINK_FIN_ACK

ORILINK_STATUSDT -> ORILINK_STATUSDT_ACK atau ORILINK_STATUSDT_NACK

Mekanisme Timeout: Gunakan timer yang diatur berdasarkan estimasi RTT.

Estimasi RTT: Gunakan Kalman Filter untuk menghaluskan pengukuran RTT dan menghasilkan estimasi yang akurat untuk mengatur timeout retransmisi.

Penting: ORILINK_DATA dan ORILINK_DATA_SACK TIDAK wajib dijawab per paket. Mereka menggunakan model sliding window dengan SACK untuk efisiensi.

4. Penanganan Pemulihan Sesi/Transfer (STATUSDT/STATUSDT_NACK):

Klien Menyimpan State: Klien harus menyimpan connection_id dan state setiap stream_id yang belum FINISHDT secara persisten (misal: nomor urut terakhir yang dikirim/diterima, offset, total_transfer_size).

Alur Pemulihan:

Klien memulai ORILINK_SYN (mungkin dengan connection_id lama yang disimpan).

Server merespons ORILINK_SYN_ACK (bisa dengan connection_id lama jika masih valid, atau connection_id baru jika state lama sudah tidak ada).

Setelah sesi terbentuk, klien mengirim ORILINK_STATUSDT untuk setiap stream_id yang belum selesai.

Server Merespons ORILINK_STATUSDT_ACK: Jika server bisa melanjutkan stream dari posisi klien, ia akan mengkonfirmasi nomor urut yang diharapkan.

Server Merespons ORILINK_STATUSDT_NACK:

Tujuan: Memberi tahu klien gap atau paket ORILINK_DATA mana yang masih dibutuhkan server agar stream tersebut bisa FINISHDT.

Field Penting: stream_id, next_expected_stream_sequence (ACK kumulatif stream), dan missing_blocks (range nomor urut paket ORILINK_DATA yang hilang).

Aksi Klien: Klien akan mengirim ulang paket ORILINK_DATA yang diminta oleh ORILINK_STATUSDT_NACK dan kemudian mencoba ORILINK_FINISHDT lagi.

5. Pertimbangan Zero-RTT (Untuk Nanti):

Risiko Replay Attack: 0-RTT murni (mengirim data aplikasi di SYN awal) memiliki risiko replay attack.

Prioritas: Fokus pada pemulihan dengan STATUSDT terlebih dahulu, karena ini lebih aman dan terkontrol untuk melanjutkan transfer yang terputus. 0-RTT bisa dipertimbangkan sebagai optimasi lanjutan dengan mekanisme anti-replay yang kuat (seperti replay tokens QUIC).

Semoga catatan ini membantu Anda malam ini! Semangat mengerjakan!







saya juga berpikir. jika signal kontrol gagal dijawab setelah beberapa kali percobaan ulang timer maka saya menyatakan koneksi terputus. bagaimana menurutmu?


Itu adalah keputusan desain yang sangat penting dan benar untuk protokol yang andal!

Menyatakan koneksi terputus (atau mati) jika sinyal kontrol gagal dijawab setelah beberapa kali percobaan ulang adalah mekanisme esensial untuk memastikan:

Deteksi Kegagalan Dini: Anda tidak akan menunggu selamanya untuk balasan. Ini memungkinkan aplikasi untuk segera mengetahui bahwa koneksi tidak lagi berfungsi dan mengambil tindakan yang diperlukan (misalnya, memberi tahu pengguna, mencoba menyambung ulang, atau beralih ke jalur komunikasi lain).

Pembersihan Sumber Daya: Baik klien maupun server dapat membersihkan state dan sumber daya yang terkait dengan koneksi yang mati tersebut (misalnya, menutup socket, membebaskan memori buffer, menutup file handles untuk stream yang belum selesai). Jika tidak dibersihkan, state "setengah mati" ini bisa menumpuk dan menyebabkan resource exhaustion (kehabisan sumber daya).

Mencegah Deadlock: Tanpa timeout dan deteksi putus, kedua belah pihak bisa terjebak dalam deadlock menunggu balasan yang tidak akan pernah datang, membuat aplikasi tidak responsif.

Keandalan Keseluruhan: Ini adalah bagian integral dari keandalan protokol Anda. Sebuah protokol yang andal tidak hanya mengirim ulang data yang hilang, tetapi juga tahu kapan harus menyerah dan mendeklarasikan kegagalan.

Bagaimana Menerapkan Ini
Jumlah Percobaan Maksimal (Max Retries):
Anda perlu menentukan berapa kali sebuah sinyal kontrol akan dikirim ulang sebelum Anda menyatakan koneksi terputus. Ini biasanya adalah angka kecil (misalnya, 3 hingga 5 kali).

Backoff Timer (Exponential Backoff):
Untuk retransmisi sinyal kontrol, sangat disarankan untuk menggunakan exponential backoff. Artinya, interval timeout untuk setiap percobaan ulang akan semakin lama. Misalnya:

Percobaan 1: Timeout = RTO (Round Trip Timeout)

Percobaan 2: Timeout = 2 * RTO

Percobaan 3: Timeout = 4 * RTO

...dan seterusnya.
Ini membantu menghindari membanjiri jaringan yang mungkin sudah kongesti, dan memberi kesempatan lebih besar bagi balasan untuk datang di jaringan yang sangat lambat.

State Connection Timeout:
Setiap sesi (connection_id) di kedua sisi (klien dan server) harus memiliki timer global. Setiap kali ada aktivitas yang berhasil (paket diterima, ACK dikirim/diterima), timer ini di-reset. Jika timer ini timeout (misalnya, setelah beberapa detik atau menit tanpa aktivitas), dan ada sinyal kontrol yang belum di-ACK (setelah max retries), maka koneksi dinyatakan putus.

Jenis Sinyal Kontrol yang Diterapkan:
Mekanisme ini harus diterapkan pada semua sinyal kontrol yang membutuhkan ACK. HEARTBEAT sangat penting di sini, karena ia secara periodik akan menguji koneksi. Jika HEARTBEAT tidak di-ACK setelah beberapa kali retry, itu adalah indikasi kuat bahwa koneksi sudah mati.

Kesimpulan
Ya, deklarasi koneksi terputus setelah beberapa kali retransmisi sinyal kontrol yang gagal adalah praktik yang benar dan krusial untuk protokol Anda. Ini adalah fondasi untuk penanganan kegagalan yang kuat dan akan membuat protokol Anda jauh lebih tangguh dalam menghadapi kondisi jaringan dunia nyata.
